https://www.acmicpc.net/problem/12920
knapsack문제를 풀고자한다.

#문제 배경
이 문제는 binary knapsack문제로 하나의 물건을 여러개로 나눌 수 없다.
이 문제는 물건의 최대 종류는 100개지만 같은 물건이 중복해서 여러개 주어질 수 있다.
예를들어 A라는 무게1, 가치1인 물건이 10000개 주어진다면
이 문제에서는 입력
w v amount (가치, 무게, 양)
1 1 10000
이렇게 주어진다.

일반적인 knapsack 알고리즘에서 이를 고려하여 최적해를 찾고자하면
for i 1->10000:
    input : 1, 1 //(w, v)
무게 1, 가치 1인 물건을 1만개 입력받아서 찾는것과 동일하다.

이때 물건의 최대 종류가 100개이므로
물건 n개, 무게 m이라고 보면 아래와 같다.
(문제 조건 : "물건의 최대 종류" <= 100, "물건의 무게" * "물건의 갯수" <= 10000, "가방의 최대무게" <= 10000)
n = (물건종류)*(각 물건의 최대갯수) -> worst = 100*10000
m = (최적해를 찾고자 하는 무게)    -> worst = 10000
dp로 푸므로 시간복잡도는 O(nm)이고 최악의 경우는
worst = 100 * 10000 * 10000 = "10^10"의 탐색이 필요하다.
이러면 시간복잡도가 O(nm)임에도 n으로 너무 큰 값이 들어와 긴 시간이 필요해진다.
"때문에 같은 물건이 여러개인 경우를 최적화하는것이 이 문제의 목표이다."

#최적화 하기 위한 아이디어
일단 1~N개를 넣는것을 모두 고려해야한다.
x bit가 2^x-1까지 표현이 가능한 점을 이용하고자 한다.
예를 들어 7을 표현하기위해서는 3bit 세자리로 1~7까지 모두 표현이 가능하다. (001, 010, 011, 100 ...)
1,2,4를 넣는것을 고려하면 1~7개를 넣는것을 고려하는것과 동일한 결과를 얻을 수 있다.

2^x-1로 딱 맞아 떨어지지않는다면 2^x-1이 표현 가능한 범위까지만 표현후 남은 오차를 따로 넣어서 고려하면된다.
예를 들어 10을 표현하려면 1,2,4로 7까지 넣는경우를 고려하면서 3(= 10-7)을 넣는것을 추가로 고려하면된다.
이렇게 할경우 1~7개까지 넣는것을 고려한다음 3 + 1~7개를 넣는것을 고려함으로써 1~10개를 모두 고려할 수 있다.


고려할 대상을 A(1),A(2),A(4),A(3)으로 보고 확인해보면

A 1개 = A(1)
A 2개 = A(2)
A 3개 = A(1) + A(2)
A 4개 = A(4)
A 5개 = A(1) + A(4)
...
A 10개 = A(3) + A(1) + A(2) + A(4)
A(1),A(2),A(4),A(3) 4개를 가방에 넣는 경우를 고려해서
A를 1~10개 넣는 경우를 고려하는것과 같은 결과를 낼 수있음을 보일 수 있다.

#결론
A 10개를 고려하는것과 A(1),A(2),A(4),A(3) 4개를 고려하는것은 같다.
따라서 A n개를 고려하는것은 (log n + 1) 개를 고려하는것과 같다. (n != 2^x)

