https://www.acmicpc.net/problem/12920
knapsack문제를 풀고자한다.

#문제 배경
이 문제는 binary knapsack문제로 하나의 물건을 여러개로 나눌 수 없다.
이 문제는 물건의 최대 종류는 100개지만 같은 물건이 중복해서 여러개 주어질 수 있다.
예를들어 A라는 무게1, 가치1인 물건이 10000개 주어진다면
이 문제에서는 입력
w v amount (가치, 무게, 양)
1 1 10000
이렇게 주어진다.

일반적인 knapsack 알고리즘에서 이를 고려하여 최적해를 찾고자하면
for i 1->10000:
    input : 1, 1 //(w, v)
무게 1, 가치 1인 물건을 1만개 입력받아서 찾는것과 동일하다.

이때 물건의 최대 종류가 100개이므로
물건 n개, 무게 m이라고 보면 아래와 같다.
(문제 조건 : "물건의 최대 종류" <= 100, "물건의 무게" * "물건의 갯수" <= 10000, "가방의 최대무게" <= 10000)
n = (물건종류)*(각 물건의 최대갯수) -> worst = 100*10000
m = (최적해를 찾고자 하는 무게)    -> worst = 10000
dp로 푸므로 시간복잡도는 O(nm)이고 최악의 경우는
worst = 100 * 10000 * 10000 = "10^10"의 탐색이 필요하다.
이러면 시간복잡도가 O(nm)임에도 n으로 너무 큰 값이 들어와 긴 시간이 필요해진다.
"때문에 같은 물건이 여러개인 경우를 최적화하는것이 이 문제의 목표이다."

#최적화 하기 위한 아이디어
이 최적화를 하기위해 n bit가 2^n-1까지 표현이 가능한 점을 이용하고자 한다.
예를 들어 7을 표현하기위해서는 3bit 세자리로 1~7까지 모두 표현이 가능하다. (001, 010, 011, 100 ...)
그러면 10까지 표현하기 위해서는 4bit가 필요하다. 하지만 일반적인 이진법에서 4bit는 15(2^4 - 1)까지 표현해버린다.

"이를 해결하기 위해 4bit자리에 평범한 이진법에서 벗어나 10 - 7(3bit까지 표현가능한 수) = 3을 가지게 하면 된다."
이 경우에는 "3, 4, 2, 1"이 각 비트의 값이 되는것이다.
이러면 0x 0001~0111은 1~7을 표현하고 0x 1001~1111은 3 + 1~7 = 4~11을 표현할 수 있다.
따라서 0x 0001~1111은 1~11까지 표현할 수 있다.

위와 같은 원리를 이용하여
어떤 물건이 무게1 가치1 개수10개 주어졌다고 가정해보자.
가방의 최대 무게는 W이고 물건A(무게1, 가치1)를 10개 입력받으면 knapsack 알고리즘은 
가방안에 물건A를 1개, 2개, 3개... 10개 넣어본 경우를 고려해 최적해(가방무게W를 초과하지 않으며 가방에 넣을 수 있는 가치의 최대치)를 구한다.

그러면 A1개묶음, A2개묶음, A4개묶음, A3개묶음 4묶음으로 고려하는 경우로 바꿔보자.
(이하 A x개 묶음 = A(x)로 바꿔적는다.)
A 1개 = A(1)
A 2개 = A(2)
A 3개 = A(1) + A(2)
A 4개 = A(4)
A 5개 = A(1) + A(4)
...
A 10개 = A(3) + A(1) + A(2) + A(4)
A(1),A(2),A(4),A(3) 4개를 가방에 넣는 경우를 고려해서
A를 1~10개 넣는 경우를 고려하는것과 같은 결과를 낼 수있음을 보일 수 있다.

#결론
A 10개를 고려하는것과 A(1),A(2),A(4),A(3) 4개를 고려하는것은 같다.
따라서 A n개를 고려하는것은 
n+1 == 2^x이라면(2의 제곱수라면) log2(n+1)개 (n=7이라면 log2(7+1) = 3, 3bit 필요)
아니라면(2의 제곱수가 아니라면) log2(n)+1개 (n=10이라면 log2(10) + 1 = 4.322 ~= 4, 4bit 필요)

